// Data Ingestion Service for Automated Music Discovery
// Handles background jobs for updating music database from external sources

import mysql from 'mysql2/promise';
import * as cron from 'node-cron';

export interface IngestionJob {
  id: string;
  source: string;
  url: string;
  parser: string;
  schedule: string;
  lastRun: Date | null;
  nextRun: Date | null;
  status: 'active' | 'paused' | 'error';
  errorMessage?: string;
}

export interface SongRecord {
  id: string;
  title: string;
  composer: string;
  textWriter?: string;
  description: string;
  sourceLink: string;
  audioLink?: string;
  source: 'IMSLP' | 'Hymnary' | 'ChoralNet' | 'MuseScore' | 'SundMusik' | 'Other';
  language?: string;
  voicing?: string;
  difficulty?: string;
  season?: string;
  theme?: string;
  period?: string;
  searchText: string;
}

// Abstract base parser class
abstract class BaseParser {
  protected delay: number;
  
  constructor(delay: number = 1000) {
    this.delay = delay;
  }
  
  abstract parse(url: string): Promise<SongRecord[]>;
  abstract getUpdateFrequency(): string;
  
  protected async delayRequest(): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, this.delay));
  }
  
  protected buildSearchText(songData: Partial<SongRecord>): string {
    const parts = [
      songData.title,
      songData.composer,
      songData.textWriter,
      songData.description,
      songData.language,
      songData.voicing,
      songData.difficulty,
      songData.season,
      songData.theme,
      songData.period
    ].filter(Boolean);
    
    return parts.join(' ');
  }
}

// IMSLP Parser for female chorus category
class IMSLPParser extends BaseParser {
  private proxyUrl = 'https://r.jina.ai/http://imslp.org/wiki/Category:For_female_chorus';
  
  constructor() {
    super(2000); // 2 second delay for IMSLP
  }
  
  async parse(url: string): Promise<SongRecord[]> {
    try {
      await this.delayRequest();
      
      const response = await fetch(this.proxyUrl, { 
        headers: { 'Accept': 'text/plain' } 
      });
      
      if (!response.ok) {
        throw new Error(`IMSLP proxy fetch failed: ${response.status}`);
      }
      
      const text = await response.text();
      const items: SongRecord[] = [];
      
      // Parse IMSLP category page for works
      const linkRegex = /\[([^\]]+)\]\((\/wiki\/[^)\s]+)[^)]*\)/g;
      let match: RegExpExecArray | null;
      
      while ((match = linkRegex.exec(text)) !== null) {
        const rawTitle = match[1];
        const path = match[2];
        
        // Only keep work pages (contain comma or parentheses)
        if (!/\(|\,/.test(rawTitle)) continue;
        
        // Extract composer from parentheses
        let title = rawTitle;
        let composer = 'Unknown';
        const parenMatch = rawTitle.match(/^(.*)\s*\(([^)]+)\)\s*$/);
        
        if (parenMatch) {
          title = parenMatch[1].trim();
          composer = parenMatch[2].trim();
        }
        
        const songData: Partial<SongRecord> = {
          title,
          composer,
          description: 'Work indexed from IMSLP female chorus category',
          sourceLink: `https://imslp.org${path}`,
          source: 'IMSLP',
          voicing: 'SSA',
        };
        
        items.push({
          id: '', // Will be generated by database
          ...songData,
          searchText: this.buildSearchText(songData)
        } as SongRecord);
      }
      
      return items;
    } catch (error) {
      console.error('IMSLP parsing error:', error);
      return [];
    }
  }
  
  getUpdateFrequency(): string {
    return 'daily'; // IMSLP updates less frequently
  }
}

// MuseScore Parser for women's choir category
class MuseScoreParser extends BaseParser {
  private proxyUrl = 'https://r.jina.ai/http://musescore.com/sheetmusic/womens-choir';
  
  constructor() {
    super(1000); // 1 second delay for MuseScore
  }
  
  async parse(url: string): Promise<SongRecord[]> {
    try {
      await this.delayRequest();
      
      const response = await fetch(this.proxyUrl, { 
        headers: { 'Accept': 'text/plain' } 
      });
      
      if (!response.ok) {
        throw new Error(`MuseScore proxy fetch failed: ${response.status}`);
      }
      
      const text = await response.text();
      const items: SongRecord[] = [];
      
      // Parse MuseScore patterns
      const titlePatterns = [
        /([^-\n]+)\s*-\s*([^-\n]+)/g,  // "Title - Composer"
        /([^,\n]+)\s*by\s*([^,\n]+)/g,  // "Title by Composer"
        /([^,\n]+)\s*composed by\s*([^,\n]+)/g  // "Title composed by Composer"
      ];
      
      titlePatterns.forEach(pattern => {
        let match: RegExpExecArray | null;
        while ((match = pattern.exec(text)) !== null) {
          const title = match[1].trim();
          const composer = match[2].trim();
          
          // Filter out invalid entries
          if (title.length < 3 || composer.length < 2) continue;
          if (title.toLowerCase().includes('musescore') || title.toLowerCase().includes('sheet music')) continue;
          
          const songData: Partial<SongRecord> = {
            title,
            composer,
            description: 'Score from MuseScore women\'s choir collection',
            sourceLink: 'https://musescore.com/sheetmusic/womens-choir',
            source: 'MuseScore',
            voicing: 'SSA',
            difficulty: 'Intermediate',
          };
          
          items.push({
            id: '', // Will be generated by database
            ...songData,
            searchText: this.buildSearchText(songData)
          } as SongRecord);
        }
      });
      
      // Remove duplicates
      const uniqueItems = items.filter((item, index, self) => 
        index === self.findIndex(i => 
          i.title.toLowerCase() === item.title.toLowerCase() && 
          i.composer.toLowerCase() === item.composer.toLowerCase()
        )
      );
      
      return uniqueItems;
    } catch (error) {
      console.error('MuseScore parsing error:', error);
      return [];
    }
  }
  
  getUpdateFrequency(): string {
    return 'every 6 hours'; // MuseScore updates more frequently
  }
}

// Sund Musik Parser for women's choir category
class SundMusikParser extends BaseParser {
  constructor() {
    super(1500); // 1.5 second delay for Sund Musik
  }
  
  async parse(url: string): Promise<SongRecord[]> {
    try {
      // Use curated list for Sund Musik (more reliable than parsing)
      const knownSongs = [
        {
          title: "Visa vid midsommartid",
          composer: "Traditional Swedish",
          voicing: "SSA",
          description: "Traditional Swedish midsummer song for women's choir",
          productSlug: "visa-vid-midsommartid-ssa"
        },
        {
          title: "Reiländer från Finnskogen", 
          composer: "Traditional Swedish",
          voicing: "SSAA",
          description: "Traditional Swedish folk dance for women's choir",
          productSlug: "reilander-fran-finnskogen-ssaa"
        },
        {
          title: "Vargsången",
          composer: "Traditional Swedish", 
          voicing: "SSAA",
          description: "Traditional Swedish wolf song for women's choir",
          productSlug: "vargsangen-ssaa"
        },
        {
          title: "Du är så vacker",
          composer: "Traditional Swedish",
          voicing: "SSAA", 
          description: "Traditional Swedish love song for women's choir",
          productSlug: "du-ar-sa-vacker-ssaa"
        },
        {
          title: "Blooming Heather",
          composer: "Traditional Scottish",
          voicing: "SAA",
          description: "Traditional Scottish folk song for women's choir",
          productSlug: "blooming-heather-saa"
        },
        {
          title: "Ja, må hon/han leva",
          composer: "Traditional Swedish",
          voicing: "SAA",
          description: "Traditional Swedish birthday song for women's choir",
          productSlug: "ja-ma-hon-han-leva-saa"
        },
        {
          title: "Jovano, Jovanke",
          composer: "Traditional Macedonian",
          voicing: "SSAA",
          description: "Traditional Macedonian folk song for women's choir",
          productSlug: "jovano-jovanke-ssaa"
        },
        {
          title: "Om jag hade vingar",
          composer: "Traditional Swedish",
          voicing: "SSAA",
          description: "Traditional Swedish folk song for women's choir",
          productSlug: "om-jag-hade-vingar-ssaa"
        },
        {
          title: "Nazad, nazad Kalino mome",
          composer: "Traditional Bulgarian",
          voicing: "SSAA",
          description: "Traditional Bulgarian folk song for women's choir",
          productSlug: "nazad-nazad-kalino-mome-ssaa"
        },
        {
          title: "Ambra – fyrstämmiga folkvisor för damkör",
          composer: "Sund Musik Collection",
          voicing: "SSAA",
          description: "Collection of four-part Swedish folk songs for women's choir",
          productSlug: "ambra-fyrstammiga-folkvisor-for-damkor"
        }
      ];
      
      const items: SongRecord[] = [];
      
      knownSongs.forEach(song => {
        const songData: Partial<SongRecord> = {
          title: song.title,
          composer: song.composer,
          description: song.description,
          sourceLink: `https://sundmusik.com/product/${song.productSlug}/`,
          source: 'SundMusik',
          voicing: song.voicing,
          language: 'Swedish',
          difficulty: 'Intermediate',
        };
        
        items.push({
          id: '', // Will be generated by database
          ...songData,
          searchText: this.buildSearchText(songData)
        } as SongRecord);
      });
      
      return items;
    } catch (error) {
      console.error('Sund Musik parsing error:', error);
      return [];
    }
  }
  
  getUpdateFrequency(): string {
    return 'weekly'; // Sund Musik updates less frequently
  }
}

// Data Ingestion Service
export class DataIngestionService {
  private db: mysql.Pool;
  private parsers: Map<string, BaseParser>;
  private jobs: Map<string, cron.ScheduledTask>;
  
  constructor(db: mysql.Pool) {
    this.db = db;
    this.parsers = new Map();
    this.jobs = new Map();
    
    // Initialize parsers
    this.parsers.set('IMSLP', new IMSLPParser());
    this.parsers.set('MuseScore', new MuseScoreParser());
    this.parsers.set('SundMusik', new SundMusikParser());
  }
  
  // Start all ingestion jobs
  async startIngestion(): Promise<void> {
    try {
      // Get active jobs from database
      const [jobs] = await this.db.execute(
        'SELECT * FROM ingestion_jobs WHERE status = "active"'
      );
      
      for (const job of jobs as IngestionJob[]) {
        await this.scheduleJob(job);
      }
      
      console.log('Data ingestion service started');
    } catch (error) {
      console.error('Failed to start ingestion service:', error);
    }
  }
  
  // Schedule a specific job
  async scheduleJob(job: IngestionJob): Promise<void> {
    try {
      const parser = this.parsers.get(job.source);
      if (!parser) {
        throw new Error(`No parser found for source: ${job.source}`);
      }
      
      // Create cron job
      const task = cron.schedule(job.schedule, async () => {
        await this.runJob(job.id);
      }, {
        scheduled: false
      });
      
      this.jobs.set(job.id, task);
      task.start();
      
      console.log(`Scheduled job for ${job.source} with schedule ${job.schedule}`);
    } catch (error) {
      console.error(`Failed to schedule job ${job.id}:`, error);
    }
  }
  
  // Run a specific job
  async runJob(jobId: string): Promise<void> {
    try {
      // Get job details
      const [jobs] = await this.db.execute(
        'SELECT * FROM ingestion_jobs WHERE id = ?',
        [jobId]
      );
      
      const job = (jobs as IngestionJob[])[0];
      if (!job) {
        throw new Error(`Job not found: ${jobId}`);
      }
      
      console.log(`Running ingestion job for ${job.source}`);
      
      // Update job status
      await this.db.execute(
        'UPDATE ingestion_jobs SET status = "active", last_run = CURRENT_TIMESTAMP WHERE id = ?',
        [jobId]
      );
      
      // Get parser and parse data
      const parser = this.parsers.get(job.source);
      if (!parser) {
        throw new Error(`No parser found for source: ${job.source}`);
      }
      
      const songs = await parser.parse(job.url);
      console.log(`Parsed ${songs.length} songs from ${job.source}`);
      
      // Insert/update songs in database
      let addedCount = 0;
      let updatedCount = 0;
      
      for (const song of songs) {
        try {
          // Check if song already exists
          const [existing] = await this.db.execute(
            'SELECT id FROM songs WHERE title = ? AND composer = ? AND source = ?',
            [song.title, song.composer, song.source]
          );
          
          if ((existing as any[]).length > 0) {
            // Update existing song
            await this.db.execute(
              `UPDATE songs SET 
                description = ?, source_link = ?, audio_link = ?, 
                language = ?, voicing = ?, difficulty = ?, season = ?, 
                theme = ?, period = ?, search_text = ?, updated_at = CURRENT_TIMESTAMP
               WHERE title = ? AND composer = ? AND source = ?`,
              [
                song.description, song.sourceLink, song.audioLink,
                song.language, song.voicing, song.difficulty, song.season,
                song.theme, song.period, song.searchText,
                song.title, song.composer, song.source
              ]
            );
            updatedCount++;
          } else {
            // Insert new song
            await this.db.execute(
              `INSERT INTO songs (id, title, composer, text_writer, description, source_link, audio_link,
                                source, language, voicing, difficulty, season, theme, period, search_text)
               VALUES (UUID(), ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
              [
                song.title, song.composer, song.textWriter, song.description,
                song.sourceLink, song.audioLink, song.source, song.language,
                song.voicing, song.difficulty, song.season, song.theme,
                song.period, song.searchText
              ]
            );
            addedCount++;
          }
        } catch (error) {
          console.error(`Failed to process song ${song.title}:`, error);
        }
      }
      
      console.log(`Job ${job.source} completed: ${addedCount} added, ${updatedCount} updated`);
      
      // Update job status
      await this.db.execute(
        'UPDATE ingestion_jobs SET status = "active", error_message = NULL WHERE id = ?',
        [jobId]
      );
      
    } catch (error) {
      console.error(`Job ${jobId} failed:`, error);
      
      // Update job status with error
      await this.db.execute(
        'UPDATE ingestion_jobs SET status = "error", error_message = ? WHERE id = ?',
        [error.message, jobId]
      );
    }
  }
  
  // Stop all jobs
  async stopIngestion(): Promise<void> {
    for (const [jobId, task] of this.jobs) {
      task.stop();
      console.log(`Stopped job ${jobId}`);
    }
    this.jobs.clear();
  }
  
  // Run job manually
  async runJobManually(jobId: string): Promise<void> {
    await this.runJob(jobId);
  }
  
  // Get job status
  async getJobStatus(jobId: string): Promise<IngestionJob | null> {
    const [jobs] = await this.db.execute(
      'SELECT * FROM ingestion_jobs WHERE id = ?',
      [jobId]
    );
    
    return (jobs as IngestionJob[])[0] || null;
  }
  
  // Get all jobs
  async getAllJobs(): Promise<IngestionJob[]> {
    const [jobs] = await this.db.execute(
      'SELECT * FROM ingestion_jobs ORDER BY created_at DESC'
    );
    
    return jobs as IngestionJob[];
  }
}

export default DataIngestionService;





